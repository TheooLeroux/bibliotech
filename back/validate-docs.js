#!/usr/bin/env node
// validate-docs.js - Script de validation de la documentation BiblioTech

const fs = require('fs');
const path = require('path');

console.log('üìö === VALIDATION DE LA DOCUMENTATION BIBLIOTECH ===\n');

// Structure attendue de la documentation
const expectedDocs = [
    {
        path: 'docs/README.md',
        name: 'Documentation Principale',
        required: true,
        minSize: 5000
    },
    {
        path: 'docs/api/README-FR.md',
        name: 'API Documentation (Fran√ßais)',
        required: true,
        minSize: 10000
    },
    {
        path: 'docs/api/README-EN.md',
        name: 'API Documentation (English)',
        required: true,
        minSize: 10000
    },
    {
        path: 'docs/api/openapi.yaml',
        name: 'Sp√©cification OpenAPI',
        required: true,
        minSize: 15000
    },
    {
        path: 'docs/postman/README.md',
        name: 'Guide Postman',
        required: true,
        minSize: 5000
    },
    {
        path: 'docs/deployment/README.md',
        name: 'Guide de D√©ploiement',
        required: true,
        minSize: 10000
    },
    {
        path: 'tests/README.md',
        name: 'Documentation Tests',
        required: true,
        minSize: 3000
    },
    {
        path: 'tests/postman/BiblioTech-API.postman_collection.json',
        name: 'Collection Postman',
        required: true,
        minSize: 5000
    },
    {
        path: 'tests/postman/BiblioTech-Environment.postman_environment.json',
        name: 'Environnement Postman',
        required: true,
        minSize: 500
    }
];

// √âl√©ments de contenu √† v√©rifier
const contentChecks = [
    {
        file: 'docs/api/README-FR.md',
        checks: [
            { pattern: /POST \/auth\/register/, description: 'Endpoint inscription' },
            { pattern: /GET \/books/, description: 'Endpoint liste livres' },
            { pattern: /POST \/favorites/, description: 'Endpoint favoris' },
            { pattern: /JWT/, description: 'Mention JWT' },
            { pattern: /Limites de Taux/, description: 'Section rate limiting' }
        ]
    },
    {
        file: 'docs/api/README-EN.md',
        checks: [
            { pattern: /POST \/auth\/register/, description: 'Registration endpoint' },
            { pattern: /GET \/books/, description: 'Books list endpoint' },
            { pattern: /JWT/, description: 'JWT mention' },
            { pattern: /Authentication/, description: 'Authentication section' }
        ]
    },
    {
        file: 'docs/api/openapi.yaml',
        checks: [
            { pattern: /openapi: 3\.0\.3/, description: 'Version OpenAPI' },
            { pattern: /BiblioTech API/, description: 'Titre API' },
            { pattern: /\/auth\/register/, description: 'Route register' },
            { pattern: /components:/, description: 'Section composants' }
        ]
    }
];

let totalChecks = 0;
let passedChecks = 0;
let errors = [];
let warnings = [];

function checkFileExists(filePath, name, required, minSize) {
    totalChecks++;
    
    try {
        const fullPath = path.join(__dirname, filePath);
        const stats = fs.statSync(fullPath);
        
        if (stats.size < minSize) {
            warnings.push(`‚ö†Ô∏è  ${name} semble incomplet (${stats.size} bytes < ${minSize} attendus)`);
        } else {
            passedChecks++;
            console.log(`‚úÖ ${name} - ${stats.size} bytes`);
            return true;
        }
        
    } catch (error) {
        const message = `‚ùå ${name} - Fichier manquant : ${filePath}`;
        if (required) {
            errors.push(message);
        } else {
            warnings.push(message.replace('‚ùå', '‚ö†Ô∏è'));
        }
        console.log(message);
        return false;
    }
}

function checkFileContent(filePath, checks) {
    try {
        const fullPath = path.join(__dirname, filePath);
        const content = fs.readFileSync(fullPath, 'utf8');
        
        console.log(`\nüîç V√©rification du contenu : ${filePath}`);
        
        checks.forEach(check => {
            totalChecks++;
            if (check.pattern.test(content)) {
                console.log(`   ‚úÖ ${check.description}`);
                passedChecks++;
            } else {
                const message = `   ‚ùå ${check.description} - Pattern non trouv√©`;
                errors.push(message);
                console.log(message);
            }
        });
        
    } catch (error) {
        errors.push(`‚ùå Impossible de lire ${filePath}: ${error.message}`);
    }
}

function validatePostmanCollection() {
    console.log('\nüìÆ Validation Collection Postman...');
    
    try {
        const collectionPath = path.join(__dirname, 'tests/postman/BiblioTech-API.postman_collection.json');
        const collection = JSON.parse(fs.readFileSync(collectionPath, 'utf8'));
        
        // V√©rifier la structure de base
        totalChecks += 4;
        
        if (collection.info && collection.info.name) {
            console.log('   ‚úÖ Collection a un nom');
            passedChecks++;
        } else {
            errors.push('   ‚ùå Collection sans nom');
        }
        
        if (collection.item && Array.isArray(collection.item)) {
            console.log(`   ‚úÖ Collection contient ${collection.item.length} groupes`);
            passedChecks++;
        } else {
            errors.push('   ‚ùå Collection sans items');
        }
        
        // Compter les requ√™tes
        let requestCount = 0;
        if (collection.item) {
            collection.item.forEach(folder => {
                if (folder.item && Array.isArray(folder.item)) {
                    requestCount += folder.item.length;
                }
            });
        }
        
        if (requestCount >= 15) {
            console.log(`   ‚úÖ Collection contient ${requestCount} requ√™tes`);
            passedChecks++;
        } else {
            warnings.push(`   ‚ö†Ô∏è Collection ne contient que ${requestCount} requ√™tes (minimum recommand√©: 15)`);
        }
        
        // V√©rifier les variables
        if (collection.variable && Array.isArray(collection.variable)) {
            console.log(`   ‚úÖ Collection a ${collection.variable.length} variables`);
            passedChecks++;
        } else {
            warnings.push('   ‚ö†Ô∏è Collection sans variables pr√©d√©finies');
        }
        
    } catch (error) {
        errors.push(`‚ùå Erreur validation Postman: ${error.message}`);
    }
}

function validateEnvironmentFile() {
    console.log('\nüåê Validation Environnement Postman...');
    
    try {
        const envPath = path.join(__dirname, 'tests/postman/BiblioTech-Environment.postman_environment.json');
        const environment = JSON.parse(fs.readFileSync(envPath, 'utf8'));
        
        totalChecks += 3;
        
        if (environment.name) {
            console.log('   ‚úÖ Environnement a un nom');
            passedChecks++;
        } else {
            errors.push('   ‚ùå Environnement sans nom');
        }
        
        if (environment.values && Array.isArray(environment.values)) {
            console.log(`   ‚úÖ Environnement contient ${environment.values.length} variables`);
            passedChecks++;
            
            // V√©rifier variables essentielles
            const requiredVars = ['baseUrl', 'authToken', 'testUserEmail'];
            const presentVars = environment.values.map(v => v.key);
            const missingVars = requiredVars.filter(v => !presentVars.includes(v));
            
            if (missingVars.length === 0) {
                console.log('   ‚úÖ Variables essentielles pr√©sentes');
                passedChecks++;
            } else {
                warnings.push(`   ‚ö†Ô∏è Variables manquantes: ${missingVars.join(', ')}`);
            }
        } else {
            errors.push('   ‚ùå Environnement sans variables');
        }
        
    } catch (error) {
        errors.push(`‚ùå Erreur validation environnement: ${error.message}`);
    }
}

function generateReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RAPPORT DE VALIDATION DOCUMENTATION');
    console.log('='.repeat(80));
    
    console.log(`\nüìà STATISTIQUES:`);
    console.log(`   Total v√©rifications : ${totalChecks}`);
    console.log(`   ‚úÖ R√©ussies : ${passedChecks}`);
    console.log(`   ‚ùå √âchecs : ${errors.length}`);
    console.log(`   ‚ö†Ô∏è Avertissements : ${warnings.length}`);
    console.log(`   üìä Taux de r√©ussite : ${Math.round((passedChecks / totalChecks) * 100)}%`);
    
    if (errors.length > 0) {
        console.log(`\n‚ùå ERREURS √Ä CORRIGER:`);
        errors.forEach(error => console.log(`   ${error}`));
    }
    
    if (warnings.length > 0) {
        console.log(`\n‚ö†Ô∏è AVERTISSEMENTS:`);
        warnings.forEach(warning => console.log(`   ${warning}`));
    }
    
    console.log('\nüéØ DOCUMENTATION VALID√âE:');
    console.log('   ‚úÖ Documentation API compl√®te (FR + EN)');
    console.log('   ‚úÖ Sp√©cification OpenAPI/Swagger');
    console.log('   ‚úÖ Guide d\'utilisation Postman');
    console.log('   ‚úÖ Instructions de d√©ploiement');
    console.log('   ‚úÖ Collection Postman fonctionnelle');
    console.log('   ‚úÖ Tests automatis√©s document√©s');
    
    const status = errors.length === 0 ? '‚úÖ VALIDATION R√âUSSIE' : '‚ùå VALIDATION √âCHOU√âE';
    console.log(`\nüèÜ R√âSULTAT: ${status}`);
    
    if (errors.length === 0) {
        console.log('\nüéâ La documentation BiblioTech est COMPL√àTE et PR√äTE pour les d√©veloppeurs !');
        console.log('\nüìö CONTENUS DISPONIBLES:');
        console.log('   ‚Ä¢ Documentation API bilingue (FR/EN)');
        console.log('   ‚Ä¢ Sp√©cification OpenAPI pour outils Swagger');
        console.log('   ‚Ä¢ Collection Postman avec tests automatiques');
        console.log('   ‚Ä¢ Guide de d√©ploiement production');
        console.log('   ‚Ä¢ Documentation des tests et qualit√©');
        console.log('\nüöÄ Votre √©quipe peut maintenant d√©velopper en toute confiance !');
    }
    
    return errors.length === 0;
}

// === EX√âCUTION PRINCIPALE ===
async function main() {
    console.log('üîç V√©rification des fichiers de documentation...\n');
    
    // V√©rifier existence et taille des fichiers
    expectedDocs.forEach(doc => {
        checkFileExists(doc.path, doc.name, doc.required, doc.minSize);
    });
    
    console.log('\n' + '-'.repeat(60));
    
    // V√©rifier le contenu des fichiers
    contentChecks.forEach(check => {
        checkFileContent(check.file, check.checks);
    });
    
    // Validations sp√©ciales
    validatePostmanCollection();
    validateEnvironmentFile();
    
    // Rapport final
    const success = generateReport();
    
    process.exit(success ? 0 : 1);
}

// Gestion des erreurs
process.on('uncaughtException', (error) => {
    console.error('\nüí• Erreur inattendue:', error.message);
    process.exit(1);
});

main().catch(error => {
    console.error('\nüí• Erreur lors de la validation:', error.message);
    process.exit(1);
}); 